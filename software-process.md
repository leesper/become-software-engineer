# 统一软件工程流程框架（Unified Software Engineering Process Framework）

> “凡治众如治寡，分数是也；斗众如斗寡，形名是也；三军之众，可使毕受敌而无败者，奇正是也。” 
> ——《孙子兵法-兵势第五》

如果我们把Coding能力很强，能够凭一己之力搞定一切的程序员比作小说中武功高强的剑客，那么一支由多人组成的工程团队就必定是一支军队。如果我们把只有一个人的队伍也看成是“团队”的特殊情况，那么对于这样的“团队”而言，要想完成不那么复杂的任务，他/她只要把自己的个人技艺训练到炉火纯青即可；但对于复杂到一定程度，要处理的事情千头万绪，需要各种专业技能才能完成的任务来说，就必须通过多人团队的方式来完成。人多就一定力量大吗？未必！就算是一支人数众多，由各种各样专业人才组成的队伍，如果没有接受过一定的工程化训练，就不可能做到实战中如臂使指，就会有败亡的危险。反过来，一支实战经验暂时不那么丰富，个人技能稍微要弱一些的队伍，如果接受了一定的工程化训练，能够在实战中通力合作，形成合力，那么他们每个人的力量就会得到加成，他们的经验就会在实践中得到锻炼和加强，失败的可能性就会降低。因此在这个世界上，只要有需要人和人之间相互协作来做成的事情，就一定存在着“系统工程”的思维方式。

软件工程是人类认识世界和改造世界的一个具体的领域，具有一定的客观规律，是“把系统的，有序的，可量化的方法应用到软件的开发，运营和维护上的过程”，它具有复杂性，不可见性，易变性，服从性和非连续性等固有属性。IT从业者有必要认识和把握这样一些规律和属性，以增进技艺，更好地进行软件工程实践活动。本文在邹欣老师的《构建之法：现代软件工程》一书的基础上进行总结和提炼，基于“敏捷软件工程”和“微软解决方案框架（MSF）”构思了一套统一软件工程流程框架，因此可以把它看作是这本书的读书笔记。但正如邹老师说的：“知识体系是构建出来的，而不是接收到的。与其灌输知识，不如自己构建”，于是我在学习的过程中有意识地尝试把书中介绍的各种流程和方法串成一根线，正所谓“阵而后战，兵法之常；运用之妙，存乎于心”，要想达到“运用之妙，存乎于心”的境界，还是要从软件工程的基本思维和基础方法开始修炼起。这也是这篇文章的目的所在。在任何社会活动中，人是最重要和最关键的影响因素，因此下面我们就先来聊聊软件工程师的个人战术素养。

## 一. 软件工程师的个人战术素养

IT行业是知识密集型行业，软件工程师最大的职业风险就是被不断出现的新技术淘汰。一方面，要掌握一些方法和技巧，提高自己的工作效率，尤其是交付的作品的质量；另一方面，把节约出来的时间用于学习新知识和锻炼身体。拓展出来的新技能和强健的体魄又能促进个人价值的最大化，形成增益的良性循环。下面我们就来谈谈有关软件工程师个人战术素养的两个主要方面：开发能力和职业成长。

### 1. 培养开发能力的几个要素
#### 1.1 测试驱动开发

软件工程师首先要做到的就是对自己的代码负责，不管是维护自己的个人项目也好，是完成具体的工作任务也好，交出来的东西要尽量保证质量好，让别人读完文档就能直接拿来用。怎么保证呢？当然是通过测试的方法来保证——软件工程师一定要写单元测试代码，并与功能代码一起维护。单元测试的主要目的是使模块的质量得到稳定的，量化的保证，它还有一个额外的好处，就是提供了代码使用的示例，单元测试如果写的特别完善，别的开发者甚至可以通过阅读单元测试代码来学习和掌握模块的使用。比如下面这段Go语言单元测试代码就展示了怎样在CouchDB中保存一个大的文档数据：

```go
func TestCreateLargeDoc(t *testing.T) {
	var buf bytes.Buffer
	// 10MB
	for i := 0; i < 110*1024; i++ {
		buf.WriteString("0123456789")
	}
	doc := map[string]interface{}{"data": buf.String()}
	if err := testsDB.Set("large", doc); err != nil {
		t.Error(`db set error`, err)
	}
	doc, err := testsDB.Get("large", nil)
	if err != nil {
		t.Error(`db get error`, err)
	}
	if doc["_id"].(string) != "large" {
		t.Errorf("doc[_id] = %s, want large", doc["_id"].(string))
	}
	err = testsDB.DeleteDoc(doc)
	if err != nil {
		t.Error(`db delete doc error`, err)
	}
}
```

编写单元测试需要遵循一些基本的规范：
* 在最基本的功能/参数上验证程序正确性
* 必须由最熟悉代码的人（程序作者）来写
* 测试过后相关状态保持不变
* 测试速度要快，几秒钟内完成
* 测试产生可重复，一致的结果
* 独立性：不依赖于别的测试，可人为构造数据保持测试独立性
* 覆盖所有代码路径，但100%的覆盖率并不代表100%正确性，代码覆盖率对本该实现但并没有实现的功能无能为力
* 能够集成到自动测试框架中
* 和产品代码一起保存和维护

测试前，我们要做一些必要的准备（setup），比如插入一些用于测试的样例数据；测试后我们要清理相关数据（teardown），使测试过后相关状态保持不变。值得注意的是，现代编程语言一般都集成了自己的测试框架。以Go语言为例，我们可以在一个叫TestMain()的函数中编写我们自己的setup()和teardown()函数，并在二者之间运行所有的单元测试代码：
```
func TestMain(m *testing.M) {
	setup()
	code := m.Run()
	teardown()
	os.Exit(code)
}
```
Go语言规定了凡是以“test”结尾的代码文件都是测试文件，所有的单元测试函数都以Test开头，只要在命令行运行`go test`命令就能自动运行所有的单元测试并输出结果，除此之外Go语言还可以编写Example示例函数来展示函数用法，Godoc工具会使用相关的示例函数自动生成文档，例如下面这个函数展示了标准库中`stringutil.Reverse()`函数的使用方法：

```go
func ExampleReverse() {
    fmt.Println(stringutil.Reverse("hello"))
    // Output: olleh
}
```
随着模块功能的演进，相关的测试用例也在不断演进，这些测试用例集就构成了模块功能的基准线。作为回归测试（Regression Test）的基础，如果有任何一个测试用例失败了，就说明模块的功能从正常工作的稳定状态退化到了不正常的不稳定状态。这样一来，不管是增加新功能还是修复bug，回归测试就能确保新的代码实现了期望的功能或者修复了bug，而没有破坏模块原有的功能。

#### 1.2 效能分析工具

除了没有bug，软件工程师通常还希望自己的代码运行的又快又好，效率较高，那么除了必要的单元测试技能外，还需要掌握一定的效能分析工具，这些效能分析工具能够分析代码运行的整理情况，模块和函数之间的调用关系拓扑图，以及每个函数耗费的时间，通过对这些数据进行分析，我们就可以定位代码运行效率较低的位置，进行有的放矢的优化工作。

#### 1.3 重视个人开发流程的训练

卡耐基梅隆大学（CMU)的能力成熟度模型（CMMI)是用来衡量一个团队能力的一套模型。CMU的专家们对软件工程师也有一套模型，叫个人软件流程（PSP），PSP2.1展示了一个软件工程师在接到一个任务后应该怎么做：

1. 计划：估计任务需要多少时间
2. 开发：分析需求，生成设计文档，设计复审，代码规范，具体设计，具体编码，代码复审，测试
3. 报告：记录用时，测试报告，计算工作量，事后总结并提出过程改进计划

有丰富经验的工程师会在“需求分析”和“测试”这两方面明显地要花更多时间，但是在编码上，要花更少的时间——花在写代码上的时间反而少了。从我维护个人开源项目的经验上来看，分析需求，生成文档和测试花的时间是最多的。我得先想清楚代码编写的思路，才能粗略估算完成这个任务需要多少时间，特别是对于比较复杂的代码，我会写一篇文章详细阐述关键代码的设计思路，防止时间长了之后自己忘记当初为什么要这样写了，然后我会将功能代码和相关的测试代码发布到Github上，并撰写尽可能详细的说明文档。如果别的程序员对这个项目感兴趣，他们就会通过各种方式和我交流，个别极其认真的还会提出代码的设计缺陷和bug，这也就相当于设计和代码复审了，因此文档非常重要。

#### 1.4 二人战斗小组
### 2. 工程师的职业成长路径
#### 2.1 个人能力的衡量
##### 2.1.1 技术能力
##### 2.1.2 领域知识
##### 2.1.3 职业技能
##### 2.1.4 实际成果
STAR原则
#### 2.2 工程师的职业发展
##### 2.2.1 认证考试
##### 2.2.2 职业成长

## 二. 软件工程的实施（战略阶段）
### 1. 构思阶段
研究和分析需求
开始组建团队
### 2. 计划阶段
产品待办事项清单（Product Backlog）
冲刺开发待办事项清单（Sprint Backlog）
## 三. 软件工程的实施（战役阶段）
### 1. 开发阶段
拿到任务后，开发人员需要做什么
开发阶段的日常管理
测试小组要做的工作
### 2. 稳定阶段
基本流程
测试小组要做的工作
质量保障
### 3. 部署阶段
版本演进的一般方式
怎样解决影响产品发布的问题
测试小组要做的工作
事后诸葛亮会议
## 四. 总结
## 五. 参考文献