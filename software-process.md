# 统一软件工程流程框架（Unified Software Engineering Process Framework）

> “凡治众如治寡，分数是也；斗众如斗寡，形名是也；三军之众，可使毕受敌而无败者，奇正是也。” 
> ——《孙子兵法-兵势第五》

如果我们把Coding能力很强，能够凭一己之力搞定一切的程序员比作小说中武功高强的剑客，那么一支由多人组成的工程团队就必定是一支军队。如果我们把只有一个人的队伍也看成是“团队”的特殊情况，那么对于这样的“团队”而言，要想完成不那么复杂的任务，他/她只要把自己的个人技艺训练到炉火纯青即可；但对于复杂到一定程度，要处理的事情千头万绪，需要各种专业技能才能完成的任务来说，就必须通过多人团队的方式来完成。人多就一定力量大吗？未必！就算是一支人数众多，由各种各样专业人才组成的队伍，如果没有接受过一定的工程化训练，就不可能做到实战中如臂使指，就会有败亡的危险。反过来，一支实战经验暂时不那么丰富，个人技能稍微要弱一些的队伍，如果接受了一定的工程化训练，能够在实战中通力合作，形成合力，那么他们每个人的力量就会得到加成，他们的经验就会在实践中得到锻炼和加强，失败的可能性就会降低。因此在这个世界上，只要有需要人和人之间相互协作来做成的事情，就一定存在着“系统工程”的思维方式。

软件工程是人类认识世界和改造世界的一个具体的领域，具有一定的客观规律，是“把系统的，有序的，可量化的方法应用到软件的开发，运营和维护上的过程”，它具有复杂性，不可见性，易变性，服从性和非连续性等固有属性。IT从业者有必要认识和把握这样一些规律和属性，以增进技艺，更好地进行软件工程实践活动。本文在邹欣老师的《构建之法：现代软件工程》一书的基础上进行总结和提炼，基于“敏捷软件工程”和“微软解决方案框架（MSF）”构思了一套统一软件工程流程框架，因此可以把它看作是这本书的读书笔记。但正如邹老师说的：“知识体系是构建出来的，而不是接收到的。与其灌输知识，不如自己构建”，于是我在学习的过程中有意识地尝试把书中介绍的各种流程和方法串成一根线，正所谓“阵而后战，兵法之常；运用之妙，存乎于心”，要想达到“运用之妙，存乎于心”的境界，还是要从软件工程的基本思维和基础方法开始修炼起。这也是这篇文章的目的所在。在任何社会活动中，人是最重要和最关键的影响因素，因此下面我们就先来聊聊软件工程师的个人战术素养。

## 一. 软件工程师的个人战术素养

IT行业是知识密集型行业，软件工程师最大的职业风险就是被不断出现的新技术淘汰。一方面，要掌握一些方法和技巧，提高自己的工作效率，尤其是交付的作品的质量；另一方面，把节约出来的时间用于学习新知识和锻炼身体。拓展出来的新技能和强健的体魄又能促进个人价值的最大化，形成增益的良性循环。下面我们就来谈谈有关软件工程师个人战术素养的两个主要方面：开发能力和职业成长。

### 1. 培养开发能力的几个要素
#### 1.1 测试驱动开发

软件工程师首先要做到的就是对自己的代码负责，不管是维护自己的个人项目也好，是完成具体的工作任务也好，交出来的东西要尽量保证质量好，让别人读完文档就能直接拿来用。怎么保证呢？当然是通过测试的方法来保证——软件工程师一定要写单元测试代码，并与功能代码一起维护。单元测试的主要目的是使模块的质量得到稳定的，量化的保证，它还有一个额外的好处，就是提供了代码使用的示例，单元测试如果写的特别完善，别的开发者甚至可以通过阅读单元测试代码来学习和掌握模块的使用。比如下面这段Go语言单元测试代码就展示了怎样在CouchDB中保存一个大的文档数据：

```go
func TestCreateLargeDoc(t *testing.T) {
	var buf bytes.Buffer
	// 10MB
	for i := 0; i < 110*1024; i++ {
		buf.WriteString("0123456789")
	}
	doc := map[string]interface{}{"data": buf.String()}
	if err := testsDB.Set("large", doc); err != nil {
		t.Error(`db set error`, err)
	}
	doc, err := testsDB.Get("large", nil)
	if err != nil {
		t.Error(`db get error`, err)
	}
	if doc["_id"].(string) != "large" {
		t.Errorf("doc[_id] = %s, want large", doc["_id"].(string))
	}
	err = testsDB.DeleteDoc(doc)
	if err != nil {
		t.Error(`db delete doc error`, err)
	}
}
```

编写单元测试需要遵循一些基本的规范：
* 在最基本的功能/参数上验证程序正确性
* 必须由最熟悉代码的人（程序作者）来写
* 测试过后相关状态保持不变
* 测试速度要快，几秒钟内完成
* 测试产生可重复，一致的结果
* 独立性：不依赖于别的测试，可人为构造数据保持测试独立性
* 覆盖所有代码路径，但100%的覆盖率并不代表100%正确性，代码覆盖率对本该实现但并没有实现的功能无能为力
* 能够集成到自动测试框架中
* 和产品代码一起保存和维护

测试前，我们要做一些必要的准备（setup），比如插入一些用于测试的样例数据；测试后我们要清理相关数据（teardown），使测试过后相关状态保持不变。值得注意的是，现代编程语言一般都集成了自己的测试框架。以Go语言为例，我们可以在一个叫TestMain()的函数中编写我们自己的setup()和teardown()函数，并在二者之间运行所有的单元测试代码：
```
func TestMain(m *testing.M) {
	setup()
	code := m.Run()
	teardown()
	os.Exit(code)
}
```
Go语言规定了凡是以“test”结尾的代码文件都是测试文件，所有的单元测试函数都以Test开头，只要在命令行运行`go test`命令就能自动运行所有的单元测试并输出结果，除此之外Go语言还可以编写Example示例函数来展示函数用法，Godoc工具会使用相关的示例函数自动生成文档，例如下面这个函数展示了标准库中`stringutil.Reverse()`函数的使用方法：

```go
func ExampleReverse() {
    fmt.Println(stringutil.Reverse("hello"))
    // Output: olleh
}
```
随着模块功能的演进，相关的测试用例也在不断演进，这些测试用例集就构成了模块功能的基准线。作为回归测试（Regression Test）的基础，如果有任何一个测试用例失败了，就说明模块的功能从正常工作的稳定状态退化到了不正常的不稳定状态。这样一来，不管是增加新功能还是修复bug，回归测试就能确保新的代码实现了期望的功能或者修复了bug，而没有破坏模块原有的功能。

#### 1.2 效能分析工具

除了没有bug，软件工程师通常还希望自己的代码运行的又快又好，效率较高，那么除了必要的单元测试技能外，还需要掌握一定的效能分析工具，这些效能分析工具能够分析代码运行的整理情况，模块和函数之间的调用关系拓扑图，以及每个函数耗费的时间，通过对这些数据进行分析，我们就可以定位代码运行效率较低的位置，进行有的放矢的优化工作。

#### 1.3 重视个人开发流程的训练

卡耐基梅隆大学（CMU)的能力成熟度模型（CMMI)是用来衡量一个团队能力的一套模型。CMU的专家们对软件工程师也有一套模型，叫个人软件流程（PSP），PSP2.1展示了一个软件工程师在接到一个任务后应该怎么做：

1. 计划：估计任务需要多少时间
2. 开发：分析需求，生成设计文档，设计复审，代码规范，具体设计，具体编码，代码复审，测试
3. 报告：记录用时，测试报告，计算工作量，事后总结并提出过程改进计划

有丰富经验的工程师会在“需求分析”和“测试”这两方面明显地要花更多时间，但是在编码上，要花更少的时间——花在写代码上的时间反而少了。从我维护个人开源项目的经验上来看，分析需求，生成文档和测试花的时间是最多的。我得先想清楚代码编写的思路，才能粗略估算完成这个任务需要多少时间，特别是对于比较复杂的代码，我会写一篇文章详细阐述关键代码的设计思路，防止时间长了之后自己忘记当初为什么要这样写了，然后我会将功能代码和相关的测试代码发布到Github上，并撰写尽可能详细的说明文档。如果别的程序员对这个项目感兴趣，他们就会通过各种方式和我交流，个别极其认真的还会提出代码的设计缺陷和bug，这也就相当于设计和代码复审了，因此文档作为一种交流工具非常重要。

#### 1.4 二人战斗小组

但如果是两个开发人员组成一个小组的话，就可以做一些代码复审的工作了。这在其他行业也经常见到：

* 越野赛车（驾驶，领航员）
* 驾驶飞机（驾驶，副驾驶）
* 狙击小组（狙击手，观察手）

在软件工程领域，我们叫“结对编程”。在进行结对编程前，两位开发人员首先要达成共识——有关代码风格规范和设计规范的共识。风格规范主要是文字上的一些规定，比如花括号的位置，缩进的大小或者函数的命名等等；设计规范牵涉程序设计，模块间关系和设计模式等方方面面。达成共识后，两位开发人员就可以开始正式的结对编程活动了，他们分别扮演驾驶员和领航员的角色，前者控制键盘输入，后者起领航和提醒作用。具体来说，驾驶员写设计文档，进行编码和单元测试，而领航员审阅文档和编，考虑单元测试的覆盖，思考是否需要和如何重构，帮助驾驶员解决具体技术问题。注意驾驶员和领航员要不断地轮换角，任何一个人不要扮演同样角色超一个，每工作一小时休息15分，由领航员控制。在结对编程的活动中，任何一个任务首先都是两个人的责任，要主动参与——大家只有水平上的差距，没有级别上的差异，拥有平等决策权利。

结对编程有很多好处，首先两人合作解决问题，能够提更好的设计质和代码质量，这会给大家带来信心，高质量产出带来更高满足感。这也有利于促进团队成员之间的更有效交流：相互学习和传递经验，分享知识。最后，结对编程还能带来不间断的复审——看代码是否在“代码规范”的框架内正确地解决了问题，越早发现问题越好，越是项目后期发现的问题，修复的代价越大。同伴复审可作为自我复审和团队复审的一个有效的补充形式。复审的目的在找出代码错误，发现逻辑和算法错误，发现潜在错误和回归性错误，发现可能需要改进的地方，以及互相教育传授经验，促进团队成员熟悉项目各部分代码，熟悉应用领域相关实际知识。复审的一个标准流程如下：

1. 代码必须采用最严格编译警告等级成功编译，必要时提供Debug/Retail版本；
2. 程序员必须测试过并提供新的代码；
3. 复审者选择复审方式：面对面，独立复审或者其他方式；
4. 开发者控制流程，讲述修改的前因后果，复审者有权在任何时候打断叙述，给出自己意见；
5. 复审者逐一提供反馈意见，开发者有义务给出详尽回答；
6. 开发者负责确保所有问题得到满意的解释或解答，或确保这些问题得到处理；
7. 最后，达成复审结果一致意见：
	* 若发现致命问题，则打回，解决之前不能签入；
	* 若发现一些小问题，可有条件同意（不需复审，修改后签入）；
	* 代码可以不加新改动，直接签入；
8. 复审后整理记录，更正明显的错误，对无法很快更正的错误记录下来形成bug report，开发把所有错误记录在“我常犯的错误”表中，作为自我复审参考：
	* 症状：从用户角度看，软件出现了什么问题？
	* 程序错误：从代码的角度看，代码的什么错误导致了软件问题？
	* 根本原因：导致代码错误的根源是什么？

##### 1.4.1 如何影响对方

影响对方的方式有四种：
1. 断言（Assertion）：“就这样吧，听我的，没错”，感情强烈，适用于有充分信任的同伴；
2. 桥梁（Bridge）：“能不能再给我讲讲你的理由……”，给双方充分条件互相了解；
3. 说服（Persuasion）：“如果我们这样做，根据我的分析，我们会有这样的好处……”，有条理，建立在逻辑分析基础上，即时不能完全说服，对方也可能部分接受；
4. 吸引（Attraction）：“你想过舒适生活么？你想在家里发财么？加入我们吧，几个月后就能有上万收入”，有效地传递信息，但要注意信息准确性，夸大渲染会降低个人可信度；

##### 1.4.2 如何正确给予反馈

评论别人有三种层次：
1. 最外：评论别人的行为和结果，对方较容易接受：行为可以改正，后果可以弥补，有挽回局面的机会；
2. 中间：评论别人的习惯和动机，对方较难接受：比较难表白和澄清动机，容易引起误会；
3. 最内：评论别人的本质和固有属性，对方很难接受：无法回应，容易引起冲突和矛盾；

因此如果我们要正确地给予同伴反馈，既要正确地反馈信息让对方接受，又要避免对方造成误会引起矛盾，可以采取“三明治方法“：
1. 做好铺垫（面包）：强调双方的共同点，从团队共同愿景讲起，让对方觉得处于一个安全环境；
2. 建设性意见（肉）：少沉溺于过去，多展望将来，“过去你做的不够，但我们以后可以做的更好”；
3. 呼应开头，鼓励对方把工作做好（面包）；

当然，也不是所有的情况下结对编程都适用。首先，处于探索阶段的项目需要深入思考，不适合进行结对编程；其次，后期维护时，若技术含量不高，只需要有效复审即可；另外，对于要运行很长时间的验证测试，两个人坐在那里等待结果也比较耽误时间；然后如果团队成员在多个项目中工作，也不能充分保证足够的结对编程时间；最后，结对编程需要最大限度发挥领航员作用，若用处不大，则无需结对。

### 2. 工程师的职业成长路径
#### 2.1 个人能力的衡量
##### 2.1.1 技术能力
##### 2.1.2 领域知识
##### 2.1.3 职业技能
##### 2.1.4 实际成果
STAR原则
#### 2.2 工程师的职业发展
##### 2.2.1 认证考试
##### 2.2.2 职业成长

## 二. 软件工程的实施（战略阶段）
### 1. 构思阶段
研究和分析需求
开始组建团队
### 2. 计划阶段
产品待办事项清单（Product Backlog）
冲刺开发待办事项清单（Sprint Backlog）
## 三. 软件工程的实施（战役阶段）
### 1. 开发阶段
拿到任务后，开发人员需要做什么
开发阶段的日常管理
测试小组要做的工作
### 2. 稳定阶段
基本流程
测试小组要做的工作
质量保障
### 3. 部署阶段
版本演进的一般方式
怎样解决影响产品发布的问题
测试小组要做的工作
事后诸葛亮会议
## 四. 总结
## 五. 参考文献